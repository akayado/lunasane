seps = ['::', '>']
reserved_strs = seps

class DomainNotFoundError(Exception):
    """Raised whenever a instance corresponding to a domain could not be found or the class is not properly defined for domain handling.
    """

    def __init__(self, cls, dom):
        self.cls, self.dom = cls, dom
    def __str__(self):
        return repr(self.cls) + ', ' + repr(self.dom)


class DomainHolder:
    """Classes that hold domains must inherit the DomainHolder class and initialize count and domain_dict. Each instance of subclasses will then have a domain.

    To obtain an instance by a domain number, one must call from_domain.

    Domain numbers are generated dynamically and are not saved into any file.
    """

    def __init__(self, cls=None):
        if cls==None:
            cls = self.__class__
        self.domain = cls.count
        cls.domain_dict[self.domain] = self
        cls.count += 1

    @classmethod
    def from_domain(cls, domain):
        if domain in cls.domain_dict:
            return cls.domain_dict[domain]
        else:
            raise DomainNotFoundError(cls, domain)

class IDNotFoundError(Exception):
    def __init__(self, value, dom=None):
        self.value = value
        self.dom = dom
    def __str__(self):
        return repr(self.value) + ', ' + repr(self.dom)

class InvalidIDError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)


def new_id_classes(_default_prefix, _type_str=None, digits=4):
    """
    Generates and returns a pair of an ID class and an ID holder class.

    IDs have domains, and IDs are unique within a domain.

    An ID class can have multiple domains, thus, for example, items with the same ID in 
    different Projects are permitted (Because a Project is a domain).

    IDs also have type strings, which can be concatenated with the ID itself when generating
    a full ID.

    IDs must not contain '::'s and '>'s since they are separators.

    Full IDs can be used to identify a logical/visual item among multiple Projects and processes.

    Full IDs can be uniquely generated by traversing item posessions using IDs and their domains.
    """

    if _type_str == None:
        _type_str = _default_prefix

    class AbstractID(str):
        ids = {} # dictionary of used ids of each domain.
        default_prefix = _default_prefix # prefix for ids generated by new_id.

        def __new__(cls, domain, idobj=None):
            if cls.is_valid(idobj):
                if domain not in cls.ids:
                    cls.ids[domain] = []
                if (idobj not in cls.ids[domain]) and (idobj != None):
                    cls.register_id(domain, idobj)
                    o = super().__new__(cls, idobj)
                    o.domain = domain
                    return o
                else:
                    idobj = cls.new_id(domain)
                    cls.register_id(domain, idobj)
                    o = super().__new__(cls, idobj)
                    o.domain = domain
                    return o
            else:
                raise InvalidIDError(idobj)

        def serializable(self): # for JSON export
            return str(self)

        def typed_serializable(self): # for full ID generation
            return _type_str + seps[0] + str(self)

        @classmethod
        def is_valid(cls, idobj):
            return all([s not in str(idobj) for s in reserved_strs])

        @classmethod
        def register_id(cls, domain, idobj):
            if cls.is_valid(idobj):
                if domain in cls.ids:
                    cls.ids[domain] += [idobj]
                else:
                    cls.ids[domain] = [idobj]
            else:
                raise InvalidIDError(idobj)

        @classmethod
        def unregister_id(cls, domain, idobj):
            if domain in cls.ids:
                cls.ids[domain].pop(idobj)
            else:
                raise IDNotFoundError(idobj, domain)

        @classmethod
        def new_id(cls, domain):
            if domain not in cls.ids:
                cls.ids[domain] = []
            cnt = 0
            while True:
                idobj = cls.default_prefix + str(cnt).zfill(digits)
                if idobj not in cls.ids[domain]:
                    return idobj
                cnt += 1

    class AbstractIDHolder:
        instances = {}

        def __init__(self, domain, idobj=None):
            if idobj == None:
                self.id = AbstractID(domain)
            elif idobj.__class__ == AbstractID:
                self.id = idobj
            else:
                self.id = AbstractID(domain, idobj)

            self.__class__.instances[self.id.serializable()] = self


    return AbstractID, AbstractIDHolder

